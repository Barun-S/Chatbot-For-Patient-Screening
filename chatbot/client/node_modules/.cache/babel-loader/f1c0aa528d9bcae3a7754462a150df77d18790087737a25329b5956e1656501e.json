{"ast":null,"code":"import { J as _arrayLikeToArray, K as _unsupportedIterableToArray, u as useStoreApi, b as useStore, L as getD3Transition, _ as _slicedToArray, N as fitView, G as getTransformForBounds, p as pointToRendererPoint, a as _defineProperty } from './index-a12c80bd.js';\nimport { useMemo, useCallback } from 'react';\nimport { zoomIdentity } from 'd3-zoom';\nimport shallow from 'zustand/shallow';\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nvar initialViewportHelper = {\n  zoomIn: function zoomIn() {},\n  zoomOut: function zoomOut() {},\n  zoomTo: function zoomTo(_) {},\n  getZoom: function getZoom() {\n    return 1;\n  },\n  setViewport: function setViewport(_) {},\n  getViewport: function getViewport() {\n    return {\n      x: 0,\n      y: 0,\n      zoom: 1\n    };\n  },\n  fitView: function fitView() {},\n  setCenter: function setCenter(_, __) {},\n  fitBounds: function fitBounds(_) {},\n  project: function project(position) {\n    return position;\n  },\n  viewportInitialized: false\n};\nvar selector = function selector(s) {\n  return {\n    d3Zoom: s.d3Zoom,\n    d3Selection: s.d3Selection\n  };\n};\nvar useViewportHelper = function useViewportHelper() {\n  var store = useStoreApi();\n  var _useStore = useStore(selector, shallow),\n    d3Zoom = _useStore.d3Zoom,\n    d3Selection = _useStore.d3Selection;\n  var viewportHelperFunctions = useMemo(function () {\n    if (d3Selection && d3Zoom) {\n      return {\n        zoomIn: function zoomIn(options) {\n          return d3Zoom.scaleBy(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), 1.2);\n        },\n        zoomOut: function zoomOut(options) {\n          return d3Zoom.scaleBy(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), 1 / 1.2);\n        },\n        zoomTo: function zoomTo(zoomLevel, options) {\n          return d3Zoom.scaleTo(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), zoomLevel);\n        },\n        getZoom: function getZoom() {\n          return store.getState().transform[2];\n        },\n        setViewport: function setViewport(transform, options) {\n          var _transform$x, _transform$y, _transform$zoom;\n          var _store$getState$trans = _slicedToArray(store.getState().transform, 3),\n            x = _store$getState$trans[0],\n            y = _store$getState$trans[1],\n            zoom = _store$getState$trans[2];\n          var nextTransform = zoomIdentity.translate((_transform$x = transform.x) !== null && _transform$x !== void 0 ? _transform$x : x, (_transform$y = transform.y) !== null && _transform$y !== void 0 ? _transform$y : y).scale((_transform$zoom = transform.zoom) !== null && _transform$zoom !== void 0 ? _transform$zoom : zoom);\n          d3Zoom.transform(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), nextTransform);\n        },\n        getViewport: function getViewport() {\n          var _store$getState$trans2 = _slicedToArray(store.getState().transform, 3),\n            x = _store$getState$trans2[0],\n            y = _store$getState$trans2[1],\n            zoom = _store$getState$trans2[2];\n          return {\n            x: x,\n            y: y,\n            zoom: zoom\n          };\n        },\n        fitView: function fitView$1(options) {\n          return fitView(store.getState, options);\n        },\n        setCenter: function setCenter(x, y, options) {\n          var _store$getState = store.getState(),\n            width = _store$getState.width,\n            height = _store$getState.height,\n            maxZoom = _store$getState.maxZoom;\n          var nextZoom = typeof (options === null || options === void 0 ? void 0 : options.zoom) !== 'undefined' ? options.zoom : maxZoom;\n          var centerX = width / 2 - x * nextZoom;\n          var centerY = height / 2 - y * nextZoom;\n          var transform = zoomIdentity.translate(centerX, centerY).scale(nextZoom);\n          d3Zoom.transform(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), transform);\n        },\n        fitBounds: function fitBounds(bounds, options) {\n          var _options$padding;\n          var _store$getState2 = store.getState(),\n            width = _store$getState2.width,\n            height = _store$getState2.height,\n            minZoom = _store$getState2.minZoom,\n            maxZoom = _store$getState2.maxZoom;\n          var _getTransformForBound = getTransformForBounds(bounds, width, height, minZoom, maxZoom, (_options$padding = options === null || options === void 0 ? void 0 : options.padding) !== null && _options$padding !== void 0 ? _options$padding : 0.1),\n            _getTransformForBound2 = _slicedToArray(_getTransformForBound, 3),\n            x = _getTransformForBound2[0],\n            y = _getTransformForBound2[1],\n            zoom = _getTransformForBound2[2];\n          var transform = zoomIdentity.translate(x, y).scale(zoom);\n          d3Zoom.transform(getD3Transition(d3Selection, options === null || options === void 0 ? void 0 : options.duration), transform);\n        },\n        project: function project(position) {\n          var _store$getState3 = store.getState(),\n            transform = _store$getState3.transform,\n            snapToGrid = _store$getState3.snapToGrid,\n            snapGrid = _store$getState3.snapGrid;\n          return pointToRendererPoint(position, transform, snapToGrid, snapGrid);\n        },\n        viewportInitialized: true\n      };\n    }\n    return initialViewportHelper;\n  }, [d3Zoom, d3Selection]);\n  return viewportHelperFunctions;\n};\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nfunction useReactFlow() {\n  var viewportHelper = useViewportHelper();\n  var store = useStoreApi();\n  var getNodes = useCallback(function () {\n    var _store$getState = store.getState(),\n      nodeInternals = _store$getState.nodeInternals;\n    var nodes = Array.from(nodeInternals.values());\n    return nodes.map(function (n) {\n      return _objectSpread({}, n);\n    });\n  }, []);\n  var getNode = useCallback(function (id) {\n    var _store$getState2 = store.getState(),\n      nodeInternals = _store$getState2.nodeInternals;\n    return nodeInternals.get(id);\n  }, []);\n  var getEdges = useCallback(function () {\n    var _store$getState3 = store.getState(),\n      _store$getState3$edge = _store$getState3.edges,\n      edges = _store$getState3$edge === void 0 ? [] : _store$getState3$edge;\n    return edges.map(function (e) {\n      return _objectSpread({}, e);\n    });\n  }, []);\n  var getEdge = useCallback(function (id) {\n    var _store$getState4 = store.getState(),\n      _store$getState4$edge = _store$getState4.edges,\n      edges = _store$getState4$edge === void 0 ? [] : _store$getState4$edge;\n    return edges.find(function (e) {\n      return e.id === id;\n    });\n  }, []);\n  var setNodes = useCallback(function (payload) {\n    var _store$getState5 = store.getState(),\n      nodeInternals = _store$getState5.nodeInternals,\n      setNodes = _store$getState5.setNodes,\n      hasDefaultNodes = _store$getState5.hasDefaultNodes,\n      onNodesChange = _store$getState5.onNodesChange;\n    var nodes = Array.from(nodeInternals.values());\n    var nextNodes = typeof payload === 'function' ? payload(nodes) : payload;\n    if (hasDefaultNodes) {\n      setNodes(nextNodes);\n    } else if (onNodesChange) {\n      var changes = nextNodes.length === 0 ? nodes.map(function (node) {\n        return {\n          type: 'remove',\n          id: node.id\n        };\n      }) : nextNodes.map(function (node) {\n        return {\n          item: node,\n          type: 'reset'\n        };\n      });\n      onNodesChange(changes);\n    }\n  }, []);\n  var setEdges = useCallback(function (payload) {\n    var _store$getState6 = store.getState(),\n      _store$getState6$edge = _store$getState6.edges,\n      edges = _store$getState6$edge === void 0 ? [] : _store$getState6$edge,\n      setEdges = _store$getState6.setEdges,\n      hasDefaultEdges = _store$getState6.hasDefaultEdges,\n      onEdgesChange = _store$getState6.onEdgesChange;\n    var nextEdges = typeof payload === 'function' ? payload(edges) : payload;\n    if (hasDefaultEdges) {\n      setEdges(nextEdges);\n    } else if (onEdgesChange) {\n      var changes = nextEdges.length === 0 ? edges.map(function (edge) {\n        return {\n          type: 'remove',\n          id: edge.id\n        };\n      }) : nextEdges.map(function (edge) {\n        return {\n          item: edge,\n          type: 'reset'\n        };\n      });\n      onEdgesChange(changes);\n    }\n  }, []);\n  var addNodes = useCallback(function (payload) {\n    var nodes = Array.isArray(payload) ? payload : [payload];\n    var _store$getState7 = store.getState(),\n      nodeInternals = _store$getState7.nodeInternals,\n      setNodes = _store$getState7.setNodes,\n      hasDefaultNodes = _store$getState7.hasDefaultNodes,\n      onNodesChange = _store$getState7.onNodesChange;\n    if (hasDefaultNodes) {\n      var currentNodes = Array.from(nodeInternals.values());\n      var nextNodes = [].concat(currentNodes, _toConsumableArray(nodes));\n      setNodes(nextNodes);\n    } else if (onNodesChange) {\n      var changes = nodes.map(function (node) {\n        return {\n          item: node,\n          type: 'add'\n        };\n      });\n      onNodesChange(changes);\n    }\n  }, []);\n  var addEdges = useCallback(function (payload) {\n    var nextEdges = Array.isArray(payload) ? payload : [payload];\n    var _store$getState8 = store.getState(),\n      _store$getState8$edge = _store$getState8.edges,\n      edges = _store$getState8$edge === void 0 ? [] : _store$getState8$edge,\n      setEdges = _store$getState8.setEdges,\n      hasDefaultEdges = _store$getState8.hasDefaultEdges,\n      onEdgesChange = _store$getState8.onEdgesChange;\n    if (hasDefaultEdges) {\n      setEdges([].concat(_toConsumableArray(edges), _toConsumableArray(nextEdges)));\n    } else if (onEdgesChange) {\n      var changes = nextEdges.map(function (edge) {\n        return {\n          item: edge,\n          type: 'add'\n        };\n      });\n      onEdgesChange(changes);\n    }\n  }, []);\n  var toObject = useCallback(function () {\n    var _store$getState9 = store.getState(),\n      nodeInternals = _store$getState9.nodeInternals,\n      _store$getState9$edge = _store$getState9.edges,\n      edges = _store$getState9$edge === void 0 ? [] : _store$getState9$edge,\n      transform = _store$getState9.transform;\n    var nodes = Array.from(nodeInternals.values());\n    var _transform = _slicedToArray(transform, 3),\n      x = _transform[0],\n      y = _transform[1],\n      zoom = _transform[2];\n    return {\n      nodes: nodes.map(function (n) {\n        return _objectSpread({}, n);\n      }),\n      edges: edges.map(function (e) {\n        return _objectSpread({}, e);\n      }),\n      viewport: {\n        x: x,\n        y: y,\n        zoom: zoom\n      }\n    };\n  }, []);\n  return useMemo(function () {\n    return _objectSpread(_objectSpread({}, viewportHelper), {}, {\n      getNodes: getNodes,\n      getNode: getNode,\n      getEdges: getEdges,\n      getEdge: getEdge,\n      setNodes: setNodes,\n      setEdges: setEdges,\n      addNodes: addNodes,\n      addEdges: addEdges,\n      toObject: toObject\n    });\n  }, [viewportHelper, getNodes, getNode, getEdges, getEdge, setNodes, setEdges, addNodes, addEdges, toObject]);\n}\nexport { _toConsumableArray as _, useReactFlow as u };","map":{"version":3,"mappings":";;;;AACe,SAASA,kBAAkB,CAACC,GAAG,EAAE;EAC9C,IAAIC,KAAK,CAACC,OAAO,CAACF,GAAG,CAAC,EAAE,OAAOG,iBAAgB,CAACH,GAAG,CAAC;AACtD;ACHe,SAASI,gBAAgB,CAACC,IAAI,EAAE;EAC7C,IAAI,OAAOC,MAAM,KAAK,WAAW,IAAID,IAAI,CAACC,MAAM,CAACC,QAAQ,CAAC,IAAI,IAAI,IAAIF,IAAI,CAAC,YAAY,CAAC,IAAI,IAAI,EAAE,OAAOJ,KAAK,CAACO,IAAI,CAACH,IAAI,CAAC;AAC3H;ACFe,SAASI,kBAAkB,GAAG;EAC3C,MAAM,IAAIC,SAAS,CAAC,sIAAsI,CAAC;AAC7J;ACEe,SAASC,kBAAkB,CAACX,GAAG,EAAE;EAC9C,OAAOY,kBAAiB,CAACZ,GAAG,CAAC,IAAIa,gBAAe,CAACb,GAAG,CAAC,IAAIc,2BAA0B,CAACd,GAAG,CAAC,IAAIe,kBAAiB,EAAE;AACjH","names":["_arrayWithoutHoles","arr","Array","isArray","arrayLikeToArray","_iterableToArray","iter","Symbol","iterator","from","_nonIterableSpread","TypeError","_toConsumableArray","arrayWithoutHoles","iterableToArray","unsupportedIterableToArray","nonIterableSpread"],"sources":["C:\\Users\\barun\\OneDrive\\Documents\\btp\\chatbot\\client\\node_modules\\react-flow-renderer\\node_modules\\@babel\\runtime\\helpers\\esm\\arrayWithoutHoles.js","C:\\Users\\barun\\OneDrive\\Documents\\btp\\chatbot\\client\\node_modules\\react-flow-renderer\\node_modules\\@babel\\runtime\\helpers\\esm\\iterableToArray.js","C:\\Users\\barun\\OneDrive\\Documents\\btp\\chatbot\\client\\node_modules\\react-flow-renderer\\node_modules\\@babel\\runtime\\helpers\\esm\\nonIterableSpread.js","C:\\Users\\barun\\OneDrive\\Documents\\btp\\chatbot\\client\\node_modules\\react-flow-renderer\\node_modules\\@babel\\runtime\\helpers\\esm\\toConsumableArray.js"],"sourcesContent":["import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithoutHoles from \"./arrayWithoutHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableSpread from \"./nonIterableSpread.js\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}"]},"metadata":{},"sourceType":"module","externalDependencies":[]}