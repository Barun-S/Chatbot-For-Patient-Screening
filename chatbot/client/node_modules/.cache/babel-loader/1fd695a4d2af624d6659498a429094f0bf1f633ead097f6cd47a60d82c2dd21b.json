{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\nvar _graph = require(\"./graph.helper\");\nvar _utils = require(\"../../utils\");\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n    inDegree = _computeNodeDegree.inDegree,\n    outDegree = _computeNodeDegree.outDegree;\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n    directed = _ref.directed;\n  var rootConnectionsNodesIds = linksMatrix[rootNodeId] ? Object.keys(linksMatrix[rootNodeId]) : [];\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  var node = nodes[nodeId];\n  if (!node) {\n    if (process.env.NODE_ENV === \"development\") {\n      (0, _utils.logError)(\"graph/collapse.helper\", \"Trying to check if node \".concat(nodeId, \" is visible but its not present in nodes: \"), nodes);\n    }\n    return false;\n  }\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n    inDegree = _computeNodeDegree2.inDegree,\n    outDegree = _computeNodeDegree2.outDegree;\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n      target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","computeNodeDegree","getTargetLeafConnections","isNodeVisible","toggleLinksConnections","toggleLinksMatrixConnections","_graph","require","_utils","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","obj","configurable","writable","_isLeafDirected","inDegree","outDegree","_isLeafNotDirected","_isLeaf","nodeId","linksMatrix","directed","_computeNodeDegree","fn","undefined","reduce","acc","currentNodeConnections","_acc","rootNodeId","_ref","rootConnectionsNodesIds","leafConnections","nodes","node","process","env","NODE_ENV","logError","concat","_orphan","_computeNodeDegree2","d3Links","connectionMatrix","map","d3Link","sourceId","getId","targetId","connection","isHidden","connections","_ref2","newMatrix","link","newConnectionValue"],"sources":["C:/Users/barun/OneDrive/Documents/btp/chatbot/client/node_modules/react-d3-graph/lib/components/graph/collapse.helper.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.computeNodeDegree = computeNodeDegree;\nexports.getTargetLeafConnections = getTargetLeafConnections;\nexports.isNodeVisible = isNodeVisible;\nexports.toggleLinksConnections = toggleLinksConnections;\nexports.toggleLinksMatrixConnections = toggleLinksMatrixConnections;\n\nvar _graph = require(\"./graph.helper\");\n\nvar _utils = require(\"../../utils\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * For directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\nfunction _isLeafDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree < 1;\n}\n/**\n * For not directed graphs.\n * Check based on node degrees whether it is a leaf node or not.\n * @param {number} inDegree - the in degree for a given node.\n * @param {number} outDegree - the out degree for a given node.\n * @returns {boolean} based on the degrees tells whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeafNotDirected(inDegree, outDegree) {\n  return inDegree <= 1 && outDegree <= 1;\n}\n/**\n * Given in and out degree tells whether degrees indicate a leaf or non leaf scenario.\n * @param {string} nodeId - The id of the node to get the cardinality of.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @param {boolean} directed - whether graph in context is directed or not.\n * @returns {boolean} flag that indicates whether node is leaf or not.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction _isLeaf(nodeId, linksMatrix, directed) {\n  var _computeNodeDegree = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree.inDegree,\n      outDegree = _computeNodeDegree.outDegree;\n\n  var fn = directed ? _isLeafDirected : _isLeafNotDirected;\n  return fn(inDegree, outDegree);\n}\n/**\n * Calculates degree (in and out) of some provided node.\n * @param {string|number} nodeId - the id of the node whom degree we want to compute.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @returns {Object.<string, number>} returns object containing in and out degree of the node:\n * - inDegree: number\n * - outDegree: number\n * @memberof Graph/collapse-helper\n */\n\n\nfunction computeNodeDegree(nodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Object.keys(linksMatrix).reduce(function (acc, source) {\n    if (!linksMatrix[source]) {\n      return acc;\n    }\n\n    var currentNodeConnections = Object.keys(linksMatrix[source]);\n    return currentNodeConnections.reduce(function (_acc, target) {\n      if (nodeId === source) {\n        _acc.outDegree += linksMatrix[nodeId][target];\n      }\n\n      if (nodeId === target) {\n        _acc.inDegree += linksMatrix[source][nodeId];\n      }\n\n      return _acc;\n    }, acc);\n  }, {\n    inDegree: 0,\n    outDegree: 0\n  });\n}\n/**\n * Given a node id we want to calculate the list of leaf connections\n * @param {string} rootNodeId - node who's leafs we want to calculate.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Array.<Object.<string, string>>} a list of leaf connections.\n * What is a leaf connection? A leaf connection is a link between some node A and other node B\n * where A has id equal to rootNodeId and B has inDegree 1 and outDegree 0 (or outDegree 1 but the connection is with A).\n * @memberof Graph/collapse-helper\n */\n\n\nfunction getTargetLeafConnections(rootNodeId) {\n  var linksMatrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _ref = arguments.length > 2 ? arguments[2] : undefined,\n      directed = _ref.directed;\n\n  var rootConnectionsNodesIds = linksMatrix[rootNodeId] ? Object.keys(linksMatrix[rootNodeId]) : [];\n  return rootConnectionsNodesIds.reduce(function (leafConnections, target) {\n    if (_isLeaf(target, linksMatrix, directed)) {\n      leafConnections.push({\n        source: rootNodeId,\n        target: target\n      });\n    }\n\n    return leafConnections;\n  }, []);\n}\n/**\n * Given a node and the connections matrix, check if node should be displayed\n * NOTE: this function is meant to be used under the `collapsible` toggle, meaning\n * that the `isNodeVisible` actually is checking visibility on collapsible graphs.\n * If you think that this code is confusing and could potentially collide (ðŸ¤ž) with #_isLeaf\n * always remember that *A leaf can, throughout time, both a visible or an invisible node!*.\n *\n * @param {string} nodeId - The id of the node to get the cardinality of\n * @param  {Object.<string, Object>} nodes - an object containing all nodes mapped by their id.\n * @param {Object.<string, number>} linksMatrix - An object containing a matrix of connections of the nodes.\n * @returns {boolean} flag that indicates whether node should or not be displayed.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction isNodeVisible(nodeId, nodes, linksMatrix) {\n  var node = nodes[nodeId];\n\n  if (!node) {\n    if (process.env.NODE_ENV === \"development\") {\n      (0, _utils.logError)(\"graph/collapse.helper\", \"Trying to check if node \".concat(nodeId, \" is visible but its not present in nodes: \"), nodes);\n    }\n\n    return false;\n  }\n\n  if (nodes[nodeId]._orphan) {\n    return true;\n  }\n\n  var _computeNodeDegree2 = computeNodeDegree(nodeId, linksMatrix),\n      inDegree = _computeNodeDegree2.inDegree,\n      outDegree = _computeNodeDegree2.outDegree;\n\n  return inDegree > 0 || outDegree > 0;\n}\n/**\n * Updates d3Links by toggling given connections\n * @param {Array.<Object>} d3Links - An array containing all the d3 links.\n * @param {Array.<Object.<string, string>>} connectionMatrix - connections to toggle.\n * @returns {Array.<Object>} updated d3Links.\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksConnections(d3Links, connectionMatrix) {\n  return d3Links.map(function (d3Link) {\n    var source = d3Link.source,\n        target = d3Link.target;\n    var sourceId = (0, _graph.getId)(source);\n    var targetId = (0, _graph.getId)(target); // connectionMatrix[sourceId][targetId] can be 0 or non existent\n\n    var connection = connectionMatrix && connectionMatrix[sourceId] && connectionMatrix[sourceId][targetId];\n    var isHidden = !connection;\n    return _objectSpread({}, d3Link, {\n      isHidden: isHidden\n    });\n  });\n}\n/**\n * Update matrix given array of connections to toggle.\n * @param {Object.<string, Object>} linksMatrix - an object containing a matrix of connections of the graph, for each nodeId,\n * there is an object that maps adjacent nodes ids (string) and their values (number).\n * @param {Array.<Object.<string, string>>} connections - connections to toggle on matrix.\n * @param  {Object} config - same as {@link #graphrenderer|config in renderGraph}.\n * @param {boolean} config.directed - tells whether linksMatrix represents a directed graph or not.\n * @returns {Object.<string, Object>} updated linksMatrix\n * @memberof Graph/collapse-helper\n */\n\n\nfunction toggleLinksMatrixConnections(linksMatrix, connections, _ref2) {\n  var directed = _ref2.directed;\n  return connections.reduce(function (newMatrix, link) {\n    if (!newMatrix[link.source]) {\n      newMatrix[link.source] = {};\n    }\n\n    if (!newMatrix[link.source][link.target]) {\n      newMatrix[link.source][link.target] = 0;\n    }\n\n    var newConnectionValue = newMatrix[link.source][link.target] === 0 ? 1 : 0;\n    newMatrix[link.source][link.target] = newConnectionValue;\n\n    if (!directed) {\n      newMatrix[link.target][link.source] = newConnectionValue;\n    }\n\n    return newMatrix;\n  }, _objectSpread({}, linksMatrix));\n}"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}