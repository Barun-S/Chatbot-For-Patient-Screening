{"ast":null,"code":"import React, { memo } from 'react';\nimport cc from 'classcat';\nimport shallow from 'zustand/shallow';\nimport { b as useStore, I as getBoundsofRects, o as getRectOfNodes } from './index-a12c80bd.js';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\nvar MiniMapNode = function MiniMapNode(_ref) {\n  var x = _ref.x,\n    y = _ref.y,\n    width = _ref.width,\n    height = _ref.height,\n    style = _ref.style,\n    color = _ref.color,\n    strokeColor = _ref.strokeColor,\n    strokeWidth = _ref.strokeWidth,\n    className = _ref.className,\n    borderRadius = _ref.borderRadius,\n    shapeRendering = _ref.shapeRendering;\n  var _ref2 = style || {},\n    background = _ref2.background,\n    backgroundColor = _ref2.backgroundColor;\n  var fill = color || background || backgroundColor;\n  return /*#__PURE__*/React.createElement(\"rect\", {\n    className: cc(['react-flow__minimap-node', className]),\n    x: x,\n    y: y,\n    rx: borderRadius,\n    ry: borderRadius,\n    width: width,\n    height: height,\n    fill: fill,\n    stroke: strokeColor,\n    strokeWidth: strokeWidth,\n    shapeRendering: shapeRendering\n  });\n};\nMiniMapNode.displayName = 'MiniMapNode';\nvar MiniMapNode$1 = /*#__PURE__*/memo(MiniMapNode);\nvar defaultWidth = 200;\nvar defaultHeight = 150;\nvar selector = function selector(s) {\n  return {\n    viewBBox: {\n      x: -s.transform[0] / s.transform[2],\n      y: -s.transform[1] / s.transform[2],\n      width: s.width / s.transform[2],\n      height: s.height / s.transform[2]\n    },\n    nodes: Array.from(s.nodeInternals.values())\n  };\n};\nvar getAttrFunction = function getAttrFunction(func) {\n  return func instanceof Function ? func : function () {\n    return func;\n  };\n};\nvar MiniMap = function MiniMap(_ref) {\n  var _style$width, _style$height;\n  var style = _ref.style,\n    className = _ref.className,\n    _ref$nodeStrokeColor = _ref.nodeStrokeColor,\n    nodeStrokeColor = _ref$nodeStrokeColor === void 0 ? '#555' : _ref$nodeStrokeColor,\n    _ref$nodeColor = _ref.nodeColor,\n    nodeColor = _ref$nodeColor === void 0 ? '#fff' : _ref$nodeColor,\n    _ref$nodeClassName = _ref.nodeClassName,\n    nodeClassName = _ref$nodeClassName === void 0 ? '' : _ref$nodeClassName,\n    _ref$nodeBorderRadius = _ref.nodeBorderRadius,\n    nodeBorderRadius = _ref$nodeBorderRadius === void 0 ? 5 : _ref$nodeBorderRadius,\n    _ref$nodeStrokeWidth = _ref.nodeStrokeWidth,\n    nodeStrokeWidth = _ref$nodeStrokeWidth === void 0 ? 2 : _ref$nodeStrokeWidth,\n    _ref$maskColor = _ref.maskColor,\n    maskColor = _ref$maskColor === void 0 ? 'rgb(240, 242, 243, 0.7)' : _ref$maskColor;\n  var _useStore = useStore(selector, shallow),\n    viewBBox = _useStore.viewBBox,\n    nodes = _useStore.nodes;\n  var elementWidth = (_style$width = style === null || style === void 0 ? void 0 : style.width) !== null && _style$width !== void 0 ? _style$width : defaultWidth;\n  var elementHeight = (_style$height = style === null || style === void 0 ? void 0 : style.height) !== null && _style$height !== void 0 ? _style$height : defaultHeight;\n  var nodeColorFunc = getAttrFunction(nodeColor);\n  var nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n  var nodeClassNameFunc = getAttrFunction(nodeClassName);\n  var boundingRect = nodes.length > 0 ? getBoundsofRects(getRectOfNodes(nodes), viewBBox) : viewBBox;\n  var scaledWidth = boundingRect.width / elementWidth;\n  var scaledHeight = boundingRect.height / elementHeight;\n  var viewScale = Math.max(scaledWidth, scaledHeight);\n  var viewWidth = viewScale * elementWidth;\n  var viewHeight = viewScale * elementHeight;\n  var offset = 5 * viewScale;\n  var x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n  var y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n  var width = viewWidth + offset * 2;\n  var height = viewHeight + offset * 2;\n  var shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    width: elementWidth,\n    height: elementHeight,\n    viewBox: \"\".concat(x, \" \").concat(y, \" \").concat(width, \" \").concat(height),\n    style: style,\n    className: cc(['react-flow__minimap', className])\n  }, nodes.filter(function (node) {\n    return !node.hidden && node.width && node.height;\n  }).map(function (node) {\n    var _node$positionAbsolut, _node$positionAbsolut2, _node$positionAbsolut3, _node$positionAbsolut4;\n    return /*#__PURE__*/React.createElement(MiniMapNode$1, {\n      key: node.id,\n      x: (_node$positionAbsolut = (_node$positionAbsolut2 = node.positionAbsolute) === null || _node$positionAbsolut2 === void 0 ? void 0 : _node$positionAbsolut2.x) !== null && _node$positionAbsolut !== void 0 ? _node$positionAbsolut : 0,\n      y: (_node$positionAbsolut3 = (_node$positionAbsolut4 = node.positionAbsolute) === null || _node$positionAbsolut4 === void 0 ? void 0 : _node$positionAbsolut4.y) !== null && _node$positionAbsolut3 !== void 0 ? _node$positionAbsolut3 : 0,\n      width: node.width,\n      height: node.height,\n      style: node.style,\n      className: nodeClassNameFunc(node),\n      color: nodeColorFunc(node),\n      borderRadius: nodeBorderRadius,\n      strokeColor: nodeStrokeColorFunc(node),\n      strokeWidth: nodeStrokeWidth,\n      shapeRendering: shapeRendering\n    });\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    className: \"react-flow__minimap-mask\",\n    d: \"M\".concat(x - offset, \",\").concat(y - offset, \"h\").concat(width + offset * 2, \"v\").concat(height + offset * 2, \"h\").concat(-width - offset * 2, \"z\\n        M\").concat(viewBBox.x, \",\").concat(viewBBox.y, \"h\").concat(viewBBox.width, \"v\").concat(viewBBox.height, \"h\").concat(-viewBBox.width, \"z\"),\n    fill: maskColor,\n    fillRule: \"evenodd\"\n  }));\n};\nMiniMap.displayName = 'MiniMap';\nvar index = /*#__PURE__*/memo(MiniMap);\nexport { index as default };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import React, { memo } from 'react';\nimport cc from 'classcat';\nimport shallow from 'zustand/shallow';\nimport { b as useStore, I as getBoundsofRects, o as getRectOfNodes } from './index-a12c80bd.js';\nimport 'zustand';\nimport 'zustand/context';\nimport 'd3-zoom';\n\nvar MiniMapNode = function MiniMapNode(_ref) {\n  var x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height,\n      style = _ref.style,\n      color = _ref.color,\n      strokeColor = _ref.strokeColor,\n      strokeWidth = _ref.strokeWidth,\n      className = _ref.className,\n      borderRadius = _ref.borderRadius,\n      shapeRendering = _ref.shapeRendering;\n\n  var _ref2 = style || {},\n      background = _ref2.background,\n      backgroundColor = _ref2.backgroundColor;\n\n  var fill = color || background || backgroundColor;\n  return /*#__PURE__*/React.createElement(\"rect\", {\n    className: cc(['react-flow__minimap-node', className]),\n    x: x,\n    y: y,\n    rx: borderRadius,\n    ry: borderRadius,\n    width: width,\n    height: height,\n    fill: fill,\n    stroke: strokeColor,\n    strokeWidth: strokeWidth,\n    shapeRendering: shapeRendering\n  });\n};\n\nMiniMapNode.displayName = 'MiniMapNode';\nvar MiniMapNode$1 = /*#__PURE__*/memo(MiniMapNode);\n\nvar defaultWidth = 200;\nvar defaultHeight = 150;\n\nvar selector = function selector(s) {\n  return {\n    viewBBox: {\n      x: -s.transform[0] / s.transform[2],\n      y: -s.transform[1] / s.transform[2],\n      width: s.width / s.transform[2],\n      height: s.height / s.transform[2]\n    },\n    nodes: Array.from(s.nodeInternals.values())\n  };\n};\n\nvar getAttrFunction = function getAttrFunction(func) {\n  return func instanceof Function ? func : function () {\n    return func;\n  };\n};\n\nvar MiniMap = function MiniMap(_ref) {\n  var _style$width, _style$height;\n\n  var style = _ref.style,\n      className = _ref.className,\n      _ref$nodeStrokeColor = _ref.nodeStrokeColor,\n      nodeStrokeColor = _ref$nodeStrokeColor === void 0 ? '#555' : _ref$nodeStrokeColor,\n      _ref$nodeColor = _ref.nodeColor,\n      nodeColor = _ref$nodeColor === void 0 ? '#fff' : _ref$nodeColor,\n      _ref$nodeClassName = _ref.nodeClassName,\n      nodeClassName = _ref$nodeClassName === void 0 ? '' : _ref$nodeClassName,\n      _ref$nodeBorderRadius = _ref.nodeBorderRadius,\n      nodeBorderRadius = _ref$nodeBorderRadius === void 0 ? 5 : _ref$nodeBorderRadius,\n      _ref$nodeStrokeWidth = _ref.nodeStrokeWidth,\n      nodeStrokeWidth = _ref$nodeStrokeWidth === void 0 ? 2 : _ref$nodeStrokeWidth,\n      _ref$maskColor = _ref.maskColor,\n      maskColor = _ref$maskColor === void 0 ? 'rgb(240, 242, 243, 0.7)' : _ref$maskColor;\n\n  var _useStore = useStore(selector, shallow),\n      viewBBox = _useStore.viewBBox,\n      nodes = _useStore.nodes;\n\n  var elementWidth = (_style$width = style === null || style === void 0 ? void 0 : style.width) !== null && _style$width !== void 0 ? _style$width : defaultWidth;\n  var elementHeight = (_style$height = style === null || style === void 0 ? void 0 : style.height) !== null && _style$height !== void 0 ? _style$height : defaultHeight;\n  var nodeColorFunc = getAttrFunction(nodeColor);\n  var nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n  var nodeClassNameFunc = getAttrFunction(nodeClassName);\n  var boundingRect = nodes.length > 0 ? getBoundsofRects(getRectOfNodes(nodes), viewBBox) : viewBBox;\n  var scaledWidth = boundingRect.width / elementWidth;\n  var scaledHeight = boundingRect.height / elementHeight;\n  var viewScale = Math.max(scaledWidth, scaledHeight);\n  var viewWidth = viewScale * elementWidth;\n  var viewHeight = viewScale * elementHeight;\n  var offset = 5 * viewScale;\n  var x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n  var y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n  var width = viewWidth + offset * 2;\n  var height = viewHeight + offset * 2;\n  var shapeRendering = typeof window === 'undefined' || !!window.chrome ? 'crispEdges' : 'geometricPrecision';\n  return /*#__PURE__*/React.createElement(\"svg\", {\n    width: elementWidth,\n    height: elementHeight,\n    viewBox: \"\".concat(x, \" \").concat(y, \" \").concat(width, \" \").concat(height),\n    style: style,\n    className: cc(['react-flow__minimap', className])\n  }, nodes.filter(function (node) {\n    return !node.hidden && node.width && node.height;\n  }).map(function (node) {\n    var _node$positionAbsolut, _node$positionAbsolut2, _node$positionAbsolut3, _node$positionAbsolut4;\n\n    return /*#__PURE__*/React.createElement(MiniMapNode$1, {\n      key: node.id,\n      x: (_node$positionAbsolut = (_node$positionAbsolut2 = node.positionAbsolute) === null || _node$positionAbsolut2 === void 0 ? void 0 : _node$positionAbsolut2.x) !== null && _node$positionAbsolut !== void 0 ? _node$positionAbsolut : 0,\n      y: (_node$positionAbsolut3 = (_node$positionAbsolut4 = node.positionAbsolute) === null || _node$positionAbsolut4 === void 0 ? void 0 : _node$positionAbsolut4.y) !== null && _node$positionAbsolut3 !== void 0 ? _node$positionAbsolut3 : 0,\n      width: node.width,\n      height: node.height,\n      style: node.style,\n      className: nodeClassNameFunc(node),\n      color: nodeColorFunc(node),\n      borderRadius: nodeBorderRadius,\n      strokeColor: nodeStrokeColorFunc(node),\n      strokeWidth: nodeStrokeWidth,\n      shapeRendering: shapeRendering\n    });\n  }), /*#__PURE__*/React.createElement(\"path\", {\n    className: \"react-flow__minimap-mask\",\n    d: \"M\".concat(x - offset, \",\").concat(y - offset, \"h\").concat(width + offset * 2, \"v\").concat(height + offset * 2, \"h\").concat(-width - offset * 2, \"z\\n        M\").concat(viewBBox.x, \",\").concat(viewBBox.y, \"h\").concat(viewBBox.width, \"v\").concat(viewBBox.height, \"h\").concat(-viewBBox.width, \"z\"),\n    fill: maskColor,\n    fillRule: \"evenodd\"\n  }));\n};\n\nMiniMap.displayName = 'MiniMap';\nvar index = /*#__PURE__*/memo(MiniMap);\n\nexport { index as default };\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}